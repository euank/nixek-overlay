diff -rcN sl/Makefile sl5-1/Makefile
*** sl/Makefile	Wed Jul 22 23:00:41 1998
--- sl5-1/Makefile	Sat Jun 24 01:46:19 2000
***************
*** 5,14 ****
  #	Last Modified: 1998/ 7/22
  #==========================================
  
! CC=cc
! CFLAGS=-O
  
! sl: sl.c sl.h
! 	$(CC) $(CFLAGS) -o sl sl.c -lcurses -ltermcap
! #	$(CC) $(CFLAGS) -o sl sl.c -lcurses
  
--- 5,26 ----
  #	Last Modified: 1998/ 7/22
  #==========================================
  
! CC = gcc
  
! #DEBUGOPTS = -DDEBUG -g
  
+ # For Linux 2.0.x
+ LDFLAGS = -lncurses -ltermcap
+ CFLAGS = -Wall -O2 -DLINUX20 $(DEBUGOPTS)
+ 
+ # For Solaris
+ #LDFLAGS = -lcurses -ltermcap
+ #CFLAGS = -Wall -O2 $(DEBUGOPTS)
+ 
+ all: sl
+ 
+ sl: sl.c sl.h header.h Makefile
+ 	$(CC) $(CFLAGS) -o sl sl.c $(LDFLAGS)
+ 
+ clean:
+ 	-rm -f sl sl.o core
diff -rcN sl/README.patch5 sl5-1/README.patch5
*** sl/README.patch5	Thu Jan  1 09:00:00 1970
--- sl5-1/README.patch5	Sat Jun 24 01:47:15 2000
***************
*** 0 ****
--- 1,72 ----
+ 
+ sl5-1.patch について
+ 
+ 					2000 年 6 月 24 日
+ 					東京都立科学技術大学 泉
+ 
+ 
+ ・はじめに
+ 
+ このパッチは東大の豊田さん作 sl に新機能を追加するためのパッチです.
+ 新機能は,
+ 
+ (1) 踏切の追加
+ (2) 客車の追加
+ (3) 列車の往復
+ (4) 客車の数の乱数による決定
+ (5) 列車のスピードの乱数による決定
+ (6) 列車の往復の有無を乱数によって決定
+ (7) 列車が往復する場合は, 遮断機が一度上がりかけてから再び降りる機能
+ (8) D51 三重連 (本当は貨物列車です)
+ 
+ があります.  (1)〜(3),(7),(8) は泉による改造, (4)〜(6) は阪大の上田さ
+ んと秋山さんによる改造です.  上田さん, 秋山さんありがとうございます.
+ また, 描画の効率を上げるために 5-1 では目に見えない変更点が多数ありま
+ す.
+ 
+ 
+ ・bug fixes
+ 
+ 1. JAIST の田中さんに sl -aF を実行したとき core dump するという報告を
+ いただき, 修正を施しました.  田中さんありがとうございます.
+ 
+ 2. 往路 28 両目で core dump するというバグを発見.  5-1 では fix しまし
+ た.
+ 
+ 
+ ・動作環境
+ 
+ 動作確認は以下の OS でしてあります.
+ 
+ sparc-sun-solaris 2.3
+ sparc-sun-solaris 2.4
+ sparc-sun-solaris 2.6
+ ix86-unknown-linux 2.0 (Slackware 3.5)
+ ix86-unknown-linux 2.0 (Plamo Linux 1.4.5)
+ 
+ また, 条件付き(注意点 2 参照)で AIX 4.1.5 でも動作するという報告をいた
+ だいています.
+ 
+ 
+ ・作り方
+ 
+ % tar zxvf sl.tgz
+ % cd sl
+ % patch -p1 < ../sl5-1.patch
+ % make
+ 
+ でバイナリ sl ができるはずです.
+ 
+ 
+ ・注意点
+ 
+ 1. Solaris 2.3, 2.4 では Makefile の LDFLAGS に「-lucb -L/usr/ucblib」
+ を加えないとコンパイルできないと思います.
+ 
+ 2. AIX 4.1.5 では sl.h の中で文字列の定義に static char * を使うと 
+ core dump するという報告を新島さんにいただきました.  static をはずすと
+ 動作するようです.  新島さんありがとうございます.
+ 
+ 3. このパッチの改造ははっきりいってうっとおしいです.  先生をお怒りをかっ
+ て進路に影響を及ぼすようなことがあっても, 当方では一切関知しません.
+ 
diff -rcN sl/header.h sl5-1/header.h
*** sl/header.h	Thu Jan  1 09:00:00 1970
--- sl5-1/header.h	Sat Jun 24 01:40:21 2000
***************
*** 0 ****
--- 1,15 ----
+ /*                   *
+  *                   *
+  *                   */
+ 
+ extern int add_D51_coach();
+ extern int add_D51_coach_r();
+ extern int add_sl();
+ extern int add_man();
+ extern int add_smoke();
+ extern int add_smoke_r();
+ extern int add_cross();
+ extern int begin_gate();
+ extern int end_gate();
+ extern int x_gate();
+ extern void end_proc();
diff -rcN sl/sl.c sl5-1/sl.c
*** sl/sl.c	Wed Jul 22 23:01:01 1998
--- sl5-1/sl.c	Sat Jun 24 01:43:03 2000
***************
*** 27,53 ****
  /* sl version 1.00 : SL runs vomitting out smoke.                            */
  /*						by Toyoda Masashi 1992/12/11 */
  
! #include <curses.h>
  #include <signal.h>
  #include <unistd.h>
  #include "sl.h"
  
  int ACCIDENT  = 0;
  int LOGO      = 0;
  int FLY       = 0;
  
  int my_mvaddstr(int y, int x, char *str)
  {
!     for ( ; x < 0; ++x, ++str)
! 	if (*str == '\0')  return ERR;
!     for ( ; *str != '\0'; ++str, ++x)
! 	if (mvaddch(y, x, *str) == ERR)  return ERR;
!     return OK;
  }
  
  void option(char *str)
  {
!     extern int ACCIDENT, FLY, LONG;
  
      while (*str != '\0') {
  	switch (*str++) {
--- 27,122 ----
  /* sl version 1.00 : SL runs vomitting out smoke.                            */
  /*						by Toyoda Masashi 1992/12/11 */
  
! #include <stdio.h>
! #include <stdlib.h>
! #include <strings.h>
! #include <time.h>
! #ifdef LINUX20
!   #include <ncurses/curses.h>
! #else
!   #include <curses.h>
! #endif
  #include <signal.h>
  #include <unistd.h>
  #include "sl.h"
+ #include "header.h"
+ 
+ #define RTOL 0
+ #define LTOR 1
+ 
+ #ifndef useconds_t
+   #define USLEEP_ARG0_TYPE unsigned
+ #else
+   #define USLEEP_ARG0_TYPE useconds_t
+ #endif
  
  int ACCIDENT  = 0;
  int LOGO      = 0;
  int FLY       = 0;
+ int PASSNUM = 5;
+ int ALL_LENGTH = 0;
+ int DIREC = RTOL;
+ int WAIT_TIME = 20000;
  
  int my_mvaddstr(int y, int x, char *str)
  {
!   int i = 0;
! 
!   for ( ; x < 0; ++x, ++i) {
!     if (str[i] == '\0') {
!       return ERR;
!     }
!   }
!   if (mvaddnstr(y, x, &str[i], (int)COLS - x) == ERR) {
!     return ERR;
!   }
! 
!   return OK;
! }
! 
! int my_mvaddstr_r(int y, int x, char *str)
! {
!   int i = 0;
!   char c;
! 
!   for ( ; x >= COLS; --x, ++i) {
!     if (str[i] == '\0') {
!       return ERR;
!     }
!   }
!   for ( ; str[i] != '\0'; ++i, --x) {
!     c = str[i];
!     switch (c) {
!     case '\\':
!       c = '/';
!       break;
!     case '/':
!       c = '\\';
!       break;
!     case '(':
!       c = ')';
!       break;
!     case ')':
!       c = '(';
!       break;
!     case '[':
!       c = ']';
!       break;
!     case ']':
!       c = '[';
!       break;
!     }
!     if (mvaddch(y, x, c) == ERR) {
!       return ERR;
!     }
!   }
! 
!   return OK;
  }
  
  void option(char *str)
  {
!     extern int ACCIDENT, FLY;
  
      while (*str != '\0') {
  	switch (*str++) {
***************
*** 59,171 ****
      }
  }
  
! void main(int argc, char *argv[])
  {
!     int x, i;
  
      for (i = 1; i < argc; ++i) {
  	if (*argv[i] == '-') {
  	    option(argv[i] + 1);
  	}
      }
!     initscr();
      signal(SIGINT, SIG_IGN);
      noecho();
      leaveok(stdscr, TRUE);
      scrollok(stdscr, FALSE);
  
!     for (x = COLS - 1; ; --x) {
! 	if (LOGO == 0) {
! 	    if (add_D51(x) == ERR) break;
! 	} else {
! 	    if (add_sl(x) == ERR) break;
  	}
  	refresh();
! 	usleep(20000);
      }
      mvcur(0, COLS - 1, LINES - 1, 0);
      endwin();
  }
  
  
! int add_sl(int x)
  {
!     static char *sl[LOGOPATTERNS][LOGOHIGHT + 1]
! 	= {{LOGO1, LOGO2, LOGO3, LOGO4, LWHL11, LWHL12, DELLN},
! 	   {LOGO1, LOGO2, LOGO3, LOGO4, LWHL21, LWHL22, DELLN},
! 	   {LOGO1, LOGO2, LOGO3, LOGO4, LWHL31, LWHL32, DELLN},
! 	   {LOGO1, LOGO2, LOGO3, LOGO4, LWHL41, LWHL42, DELLN},
! 	   {LOGO1, LOGO2, LOGO3, LOGO4, LWHL51, LWHL52, DELLN},
! 	   {LOGO1, LOGO2, LOGO3, LOGO4, LWHL61, LWHL62, DELLN}};
  
!     static char *coal[LOGOHIGHT + 1]
! 	= {LCOAL1, LCOAL2, LCOAL3, LCOAL4, LCOAL5, LCOAL6, DELLN};
  
!     static char *car[LOGOHIGHT + 1]
! 	= {LCAR1, LCAR2, LCAR3, LCAR4, LCAR5, LCAR6, DELLN};
  
      int i, y, py1 = 0, py2 = 0, py3 = 0;
      
!     if (x < - LOGOLENGTH)  return ERR;
      y = LINES / 2 - 3;
  
      if (FLY == 1) {
! 	y = (x / 6) + LINES - (COLS / 6) - LOGOHIGHT;
! 	py1 = 2;  py2 = 4;  py3 = 6;
      }
      for (i = 0; i <= LOGOHIGHT; ++i) {
! 	my_mvaddstr(y + i, x, sl[(LOGOLENGTH + x) / 3 % LOGOPATTERNS][i]);
! 	my_mvaddstr(y + i + py1, x + 21, coal[i]);
! 	my_mvaddstr(y + i + py2, x + 42, car[i]);
! 	my_mvaddstr(y + i + py3, x + 63, car[i]);
      }
      if (ACCIDENT == 1) {
! 	add_man(y + 1, x + 14);
! 	add_man(y + 1 + py2, x + 45);  add_man(y + 1 + py2, x + 53);
! 	add_man(y + 1 + py3, x + 66);  add_man(y + 1 + py3, x + 74);
      }
      add_smoke(y - 1, x + LOGOFUNNEL);
      return OK;
  }
  
  
! add_D51(int x)
! {
!     static char *d51[D51PATTERNS][D51HIGHT + 1]
! 	= {{D51STR1, D51STR2, D51STR3, D51STR4, D51STR5, D51STR6, D51STR7,
! 	    D51WHL11, D51WHL12, D51WHL13, D51DEL},
! 	   {D51STR1, D51STR2, D51STR3, D51STR4, D51STR5, D51STR6, D51STR7,
! 	    D51WHL21, D51WHL22, D51WHL23, D51DEL},
! 	   {D51STR1, D51STR2, D51STR3, D51STR4, D51STR5, D51STR6, D51STR7,
! 	    D51WHL31, D51WHL32, D51WHL33, D51DEL},
! 	   {D51STR1, D51STR2, D51STR3, D51STR4, D51STR5, D51STR6, D51STR7,
! 	    D51WHL41, D51WHL42, D51WHL43, D51DEL},
! 	   {D51STR1, D51STR2, D51STR3, D51STR4, D51STR5, D51STR6, D51STR7,
! 	    D51WHL51, D51WHL52, D51WHL53, D51DEL},
! 	   {D51STR1, D51STR2, D51STR3, D51STR4, D51STR5, D51STR6, D51STR7,
! 	    D51WHL61, D51WHL62, D51WHL63, D51DEL}};
!     static char *coal[D51HIGHT + 1]
! 	= {COAL01, COAL02, COAL03, COAL04, COAL05,
! 	   COAL06, COAL07, COAL08, COAL09, COAL10, COALDEL};
! 
      int y, i, dy = 0;
  
!     if (x < - D51LENGTH)  return ERR;
      y = LINES / 2 - 5;
  
      if (FLY == 1) {
  	y = (x / 7) + LINES - (COLS / 7) - D51HIGHT;
  	dy = 1;
      }
      for (i = 0; i <= D51HIGHT; ++i) {
! 	my_mvaddstr(y + i, x, d51[(D51LENGTH + x) % D51PATTERNS][i]);
! 	my_mvaddstr(y + i + dy, x + 53, coal[i]);
      }
      if (ACCIDENT == 1) {
  	add_man(y + 2, x + 43);
  	add_man(y + 2, x + 47);
      }
      add_smoke(y - 1, x + D51FUNNEL);
      return OK;
  }
  
--- 128,657 ----
      }
  }
  
! int dirc(int y, int x)
  {
!   if (DIREC == RTOL) {
!     my_mvaddstr(y + 5, cros0l[5] + x - 1, "<-- ");
!   } else {
!     my_mvaddstr(y + 5, cros0l[5] + x - 1, " -->");
!   }
! 
!   return 0;
! }
! 
! int main(int argc, char *argv[])
! {
!     int x, i, j, k, p, ONEDIREC, len;
!     int (*sl_func)();
!     time_t t;
!     char num[10];
!     unsigned short int s;
!     char *pp;
!     char *c[D51PATTERNS][D51HIGHT+1];
  
      for (i = 1; i < argc; ++i) {
  	if (*argv[i] == '-') {
  	    option(argv[i] + 1);
  	}
      }
!     time(&t);
!     s = (unsigned short int)t;
!     seed48(&s);
! #ifdef DEBUG
!     PASSNUM = 3;
!     ONEDIREC = 1;
!     WAIT_TIME = (USLEEP_ARG0_TYPE)100;
!     signal(SIGINT, end_proc);
! #else
      signal(SIGINT, SIG_IGN);
+     PASSNUM = (int)(drand48() * 20.0) + 10;
+     if (drand48() > 0.5) {
+       ONEDIREC = 1;
+     } else {
+       ONEDIREC = 0;
+     }
+     WAIT_TIME = (USLEEP_ARG0_TYPE)(drand48() * 50000.0);
+ #endif
+     ALL_LENGTH = (3 * D51LENGTH + (PASSLENGTH * (PASSNUM - 1)) + LPASSLENGTH);
+     initscr();
      noecho();
+ #ifdef DEBUG
+     printf("%d,%d\n\r", COLS, LINES);
+     printf("Hit any key\n\r");
+     fflush(stdout);
+     getc(stdin);
+ #endif
      leaveok(stdscr, TRUE);
      scrollok(stdscr, FALSE);
+     DIREC = RTOL;
+     p = 3 * COLS / 10;
+     pp = (char*)malloc((size_t)(COLS + ALL_LENGTH + 10) * (D51HIGHT + 1) * (D51PATTERNS + 1));
+     for (i = 0; i <= (COLS + ALL_LENGTH + 1) * (D51HIGHT + 1) * D51PATTERNS; ++i) {
+       pp[i] = (char)NULL;
+     }
  
!     for (j = 0; j < D51PATTERNS; ++j) {
!       for (i = 0; i <= D51HIGHT; ++i) {
! 	c[j][i] = pp + (COLS + ALL_LENGTH + 2) * i + (COLS + ALL_LENGTH + 1) * (D51HIGHT + 1) * j;
! 	for (k = 0; k < COLS; ++k) {
! 	  strcat(c[j][i], " ");
  	}
+ 	strncat(c[j][i], d51[j][i], 53);
+ 	strncat(c[j][i], coal[i], 29);
+ 	strncat(c[j][i], d51[j][i], 53);
+ 	strncat(c[j][i], coal[i], 29);
+ 	strncat(c[j][i], d51[j][i], 53);
+ 	strncat(c[j][i], coal[i], 29);
+ 	for (k = 0; k < PASSNUM - 1; ++k) {
+ 	  strncat(c[j][i], coach[i], 88);
+ 	  if ( i == 3 ) {
+ 	    sprintf(num, "%d", k + 1);
+ 	    len = strlen(num);
+ 	    strncpy(c[j][i] + COLS + 254 + (PASSLENGTH * k), num, len);
+ 	  }
+ 	}
+ 	strncat(c[j][i], lcoach[i], 89);
+ 	if ( i == 3 ) {
+ 	  sprintf(num, "%d", k + 1);
+ 	  len = strlen(num);
+ 	  strncpy(c[j][i] + COLS + 254 + (PASSLENGTH * k), num, len);
+ 	}
+       }
+     }
+     if (FLY != 1) {
+       begin_gate(p);
+     }
+     if (LOGO == 0) {
+       sl_func = add_D51_coach;
+     } else {
+       sl_func = add_sl;
+     }
+     for (x = COLS - 1 ; ; --x) {
+       if ((*sl_func)(x, c) == ERR) break;
+       if (FLY != 1) {
+ 	if (add_cross(p) == ERR) break;
+       }
+       refresh();
+       usleep((USLEEP_ARG0_TYPE)WAIT_TIME);
+     }
+     if (FLY != 1 && LOGO == 0 && ONEDIREC == 1) {
+       x_gate(p);
+       for (x = 0; ; ++x) {
+ 	if (add_D51_coach_r(x) == ERR) break;
+ 	if (add_cross(p) == ERR) break;
  	refresh();
! 	usleep((USLEEP_ARG0_TYPE)WAIT_TIME);
!       }
!     }
!     if (FLY != 1) {
!       end_gate(p);
      }
      mvcur(0, COLS - 1, LINES - 1, 0);
      endwin();
+ 
+     return 0;
+ }
+ 
+ 
+ void end_proc() {
+     mvcur(0, COLS - 1, LINES - 1, 0);
+     endwin();
+     exit(SIGINT);
  }
  
  
! int add_cross(int p)
  {
!   int i, y, n = 20, hn;
!   static int tt;
! #ifdef DEBUG
!   char buf[100];
! #endif
! 
!   hn = n / 2;
!   if ( LOGO == 0) {
!     y = LINES / 2 - 5;
!   } else {
!     y = LINES / 2 - 7;
!   }
!   for (i = 2; i < D51HIGHT; ++i) {
!     my_mvaddstr(y + i, cros0l[i] + p, cros0[i]);
!   }
!   for (i = 8; i < D51HIGHT; ++i) {
!     my_mvaddstr(y + i, p + 5, cros3[i]);
!   }
! #ifdef DEBUG
!   sprintf(buf, "%d", tt);
!   my_mvaddstr(0, 0, buf);
! #endif
!   if ( tt % n >= 0 && tt % n < hn) {
!     my_mvaddstr(y + 4, cros0l[5] + p - 1, "O");
!     my_mvaddstr(y + 4, cros0l[5] + p + 2, "X");
!     my_mvaddstr(y + 5, cros0l[5] + p - 1, " || ");
!   } else if ( tt % n >= hn && tt % n < n) {
!     my_mvaddstr(y + 4, cros0l[5] + p - 1, "X");
!     my_mvaddstr(y + 4, cros0l[5] + p + 2, "O");
!     dirc(y, p);
!   }
!   ++tt;
! 
!   return 0;
! }
! 
  
! int begin_gate(int p)
! {
!   int i, y, n = 20, hn;
!   int tt;
  
!   hn = n / 2;
!   if ( LOGO == 0) {
!     y = LINES / 2 - 5;
!   } else {
!     y = LINES / 2 - 7;
!   }
!   
!   for (tt = 0; tt < 80; ++tt) {
!     for (i = 0; i < D51HIGHT; ++i) {
!       my_mvaddstr(y + i, p + 5, cros1[i]);
!     }
!     for (i = 2; i < D51HIGHT; ++i) {
!       my_mvaddstr(y + i, cros0l[i] + p, cros0[i]);
!     }
!     if ( tt % n >= 0 && tt % n < hn) {
!       my_mvaddstr(y + 4, cros0l[5] + p - 1, "O");
!       my_mvaddstr(y + 4, cros0l[5] + p + 2, "X");
!       my_mvaddstr(y + 5, cros0l[5] + p - 1, " || ");
!     } else if ( tt % n >= hn && tt % n < n) {
!       my_mvaddstr(y + 4, cros0l[5] + p - 1, "X");
!       my_mvaddstr(y + 4, cros0l[5] + p + 2, "O");
!       dirc(y, p);
!     }
!     my_mvaddstr(LINES + 1, COLS + 1, "");
!     refresh();
!     usleep((USLEEP_ARG0_TYPE)WAIT_TIME);
!   }
!   for (tt = 0; tt <= 15; ++tt) {
!     for (i = 0; i < D51HIGHT; ++i) {
!       my_mvaddstr(y + i, p + 5, cros2[i]);
!     }
!     for (i = 2; i < D51HIGHT; ++i) {
!       my_mvaddstr(y + i, cros0l[i] + p, cros0[i]);
!     }
!     if ( tt % n >= 0 && tt % n < hn) {
!       my_mvaddstr(y + 4, cros0l[5] + p - 1, "O");
!       my_mvaddstr(y + 4, cros0l[5] + p + 2, "X");
!       my_mvaddstr(y + 5, cros0l[5] + p - 1, " || ");
!     } else if ( tt % n >= hn && tt % n < n) {
!       my_mvaddstr(y + 4, cros0l[5] + p - 1, "X");
!       my_mvaddstr(y + 4, cros0l[5] + p + 2, "O");
!       dirc(y, p);
!     }
!     my_mvaddstr(LINES + 1, COLS + 1, "");
!     refresh();
!     usleep((USLEEP_ARG0_TYPE)WAIT_TIME);
!   }
!   for (tt = 0; tt <= 20; ++tt) {
!     for (i = 0; i < D51HIGHT; ++i) {
!       my_mvaddstr(y + i, p + 5, cros3[i]);
!     }
!     for (i = 2; i < D51HIGHT; ++i) {
!       my_mvaddstr(y + i, cros0l[i] + p, cros0[i]);
!     }
!     if ( tt % n >= 0 && tt % n < hn) {
!       my_mvaddstr(y + 4, cros0l[5] + p - 1, "O");
!       my_mvaddstr(y + 4, cros0l[5] + p + 2, "X");
!       my_mvaddstr(y + 5, cros0l[5] + p - 1, " || ");
!     } else if ( tt % n >= hn && tt % n < n) {
!       my_mvaddstr(y + 4, cros0l[5] + p - 1, "X");
!       my_mvaddstr(y + 4, cros0l[5] + p + 2, "O");
!       dirc(y, p);
!     }
!     my_mvaddstr(LINES + 1, COLS + 1, "");
!     refresh();
!     usleep((USLEEP_ARG0_TYPE)WAIT_TIME);
!   }
! 
!   return 0;
! }
! 
! 
! int end_gate(int p)
! {
!   int i, y, n = 20, hn;
!   int tt;
! 
!   hn = n / 2;
!   if ( LOGO == 0) {
!     y = LINES / 2 - 5;
!   } else {
!     y = LINES / 2 - 7;
!   }
!   
!   for (tt = 0; tt <= 20; ++tt) {
!     for (i = 0; i < D51HIGHT; ++i) {
!       my_mvaddstr(y + i, p + 5, cros3[i]);
!     }
!     for (i = 2; i < D51HIGHT; ++i) {
!       my_mvaddstr(y + i, cros0l[i] + p, cros0[i]);
!     }
!     if ( tt % n >= 0 && tt % n < hn) {
!       my_mvaddstr(y + 4, cros0l[5] + p - 1, "O");
!       my_mvaddstr(y + 4, cros0l[5] + p + 2, "X");
!       my_mvaddstr(y + 5, cros0l[5] + p - 1, " || ");
!     } else if ( tt % n >= hn && tt % n < n) {
!       my_mvaddstr(y + 4, cros0l[5] + p - 1, "X");
!       my_mvaddstr(y + 4, cros0l[5] + p + 2, "O");
!       dirc(y, p);
!     }
!     my_mvaddstr(LINES + 1, COLS + 1, "");
!     refresh();
!     usleep((USLEEP_ARG0_TYPE)WAIT_TIME);
!   }
!   for (tt = 0; tt <= 15; ++tt) {
!     for (i = 0; i < D51HIGHT; ++i) {
!       my_mvaddstr(y + i, p + 5, cros2[i]);
!     }
!     for (i = 2; i < D51HIGHT; ++i) {
!       my_mvaddstr(y + i, cros0l[i] + p, cros0[i]);
!     }
!     if ( tt % n >= 0 && tt % n < hn) {
!       my_mvaddstr(y + 4, cros0l[5] + p - 1, "O");
!       my_mvaddstr(y + 4, cros0l[5] + p + 2, "X");
!       my_mvaddstr(y + 5, cros0l[5] + p - 1, " || ");
!     } else if ( tt % n >= hn && tt % n < n) {
!       my_mvaddstr(y + 4, cros0l[5] + p - 1, "X");
!       my_mvaddstr(y + 4, cros0l[5] + p + 2, "O");
!       dirc(y, p);
!     }
!     my_mvaddstr(LINES + 1, COLS + 1, "");
!     refresh();
!     usleep((USLEEP_ARG0_TYPE)WAIT_TIME);
!   }
!   for (tt = 0; tt < 80; ++tt) {
!     for (i = 0; i < D51HIGHT; ++i) {
!       my_mvaddstr(y + i, p + 5, cros1[i]);
!     }
!     for (i = 2; i < D51HIGHT; ++i) {
!       my_mvaddstr(y + i, cros0l[i] + p, cros0[i]);
!     }
!     my_mvaddstr(y + 4, cros0l[5] + p - 1, "X");
!     my_mvaddstr(y + 4, cros0l[5] + p + 2, "X");
!     my_mvaddstr(LINES + 1, COLS + 1, "");
!     my_mvaddstr(y + 5, cros0l[5] + p - 1, " || ");
!     refresh();
!     usleep((USLEEP_ARG0_TYPE)WAIT_TIME);
!   }
  
+   return 0;
+ }
+ 
+ 
+ int x_gate(int p)
+ {
+   int i, y, n = 20, hn;
+   int tt;
+ 
+   hn = n / 2;
+   if ( LOGO == 0) {
+     y = LINES / 2 - 5;
+   } else {
+     y = LINES / 2 - 7;
+   }
+   
+   for (tt = 0; tt <= 20; ++tt) {
+     for (i = 0; i < D51HIGHT; ++i) {
+       my_mvaddstr(y + i, p + 5, cros3[i]);
+     }
+     for (i = 2; i < D51HIGHT; ++i) {
+       my_mvaddstr(y + i, cros0l[i] + p, cros0[i]);
+     }
+     if ( tt % n >= 0 && tt % n < hn) {
+       my_mvaddstr(y + 4, cros0l[5] + p - 1, "O");
+       my_mvaddstr(y + 4, cros0l[5] + p + 2, "X");
+       my_mvaddstr(y + 5, cros0l[5] + p - 1, " || ");
+     } else if ( tt % n >= hn && tt % n < n) {
+       my_mvaddstr(y + 4, cros0l[5] + p - 1, "X");
+       my_mvaddstr(y + 4, cros0l[5] + p + 2, "O");
+       dirc(y, p);
+     }
+     my_mvaddstr(LINES + 1, COLS + 1, "");
+     refresh();
+     usleep((USLEEP_ARG0_TYPE)WAIT_TIME);
+   }
+   for (tt = 0; tt <= 10; ++tt) {
+     for (i = 0; i < D51HIGHT; ++i) {
+       my_mvaddstr(y + i, p + 5, cros2[i]);
+     }
+     for (i = 2; i < D51HIGHT; ++i) {
+       my_mvaddstr(y + i, cros0l[i] + p, cros0[i]);
+     }
+     if ( tt % n >= 0 && tt % n < hn) {
+       my_mvaddstr(y + 4, cros0l[5] + p - 1, "O");
+       my_mvaddstr(y + 4, cros0l[5] + p + 2, "X");
+       my_mvaddstr(y + 5, cros0l[5] + p - 1, " || ");
+     } else if ( tt % n >= hn && tt % n < n) {
+       my_mvaddstr(y + 4, cros0l[5] + p - 1, "X");
+       my_mvaddstr(y + 4, cros0l[5] + p + 2, "O");
+       dirc(y, p);
+     }
+     my_mvaddstr(LINES + 1, COLS + 1, "");
+     refresh();
+     usleep((USLEEP_ARG0_TYPE)WAIT_TIME);
+   }
+   DIREC = ( DIREC + 1 ) % 2;
+   for (tt = 0; tt <= 10; ++tt) {
+     for (i = 0; i < D51HIGHT; ++i) {
+       my_mvaddstr(y + i, p + 5, cros2[i]);
+     }
+     for (i = 2; i < D51HIGHT; ++i) {
+       my_mvaddstr(y + i, cros0l[i] + p, cros0[i]);
+     }
+     if ( tt % n >= 0 && tt % n < hn) {
+       my_mvaddstr(y + 4, cros0l[5] + p - 1, "O");
+       my_mvaddstr(y + 4, cros0l[5] + p + 2, "X");
+       my_mvaddstr(y + 5, cros0l[5] + p - 1, " || ");
+     } else if ( tt % n >= hn && tt % n < n) {
+       my_mvaddstr(y + 4, cros0l[5] + p - 1, "X");
+       my_mvaddstr(y + 4, cros0l[5] + p + 2, "O");
+       dirc(y, p);
+     }
+     my_mvaddstr(LINES + 1, COLS + 1, "");
+     refresh();
+     usleep((USLEEP_ARG0_TYPE)WAIT_TIME);
+   }
+   for (tt = 0; tt <= 20; ++tt) {
+     for (i = 0; i < D51HIGHT; ++i) {
+       my_mvaddstr(y + i, p + 5, cros3[i]);
+     }
+     for (i = 2; i < D51HIGHT; ++i) {
+       my_mvaddstr(y + i, cros0l[i] + p, cros0[i]);
+     }
+     if ( tt % n >= 0 && tt % n < hn) {
+       my_mvaddstr(y + 4, cros0l[5] + p - 1, "O");
+       my_mvaddstr(y + 4, cros0l[5] + p + 2, "X");
+       my_mvaddstr(y + 5, cros0l[5] + p - 1, " || ");
+     } else if ( tt % n >= hn && tt % n < n) {
+       my_mvaddstr(y + 4, cros0l[5] + p - 1, "X");
+       my_mvaddstr(y + 4, cros0l[5] + p + 2, "O");
+       dirc(y, p);
+     }
+     my_mvaddstr(LINES + 1, COLS + 1, "");
+     refresh();
+     usleep((USLEEP_ARG0_TYPE)WAIT_TIME);
+   }
+ 
+   return 0;
+ }
+ 
+ 
+ int add_sl(int x, char *c[])
+ {
      int i, y, py1 = 0, py2 = 0, py3 = 0;
      
!     if (x < - LOGOLENGTH) {
!       return ERR;
!     }
      y = LINES / 2 - 3;
  
      if (FLY == 1) {
!         y = (x / 6) + LINES - (COLS / 6) - LOGOHIGHT;
!         py1 = 2;  py2 = 4;  py3 = 6;
      }
      for (i = 0; i <= LOGOHIGHT; ++i) {
!         my_mvaddstr(y + i, x, sl[(LOGOLENGTH + x) / 3 % LOGOPATTERNS][i]);
!         my_mvaddstr(y + i + py1, x + 21, lcoal[i]);
!         my_mvaddstr(y + i + py2, x + 42, car[i]);
!         my_mvaddstr(y + i + py3, x + 63, car[i]);
      }
      if (ACCIDENT == 1) {
!         add_man(y + 1, x + 14);
!         add_man(y + 1 + py2, x + 45);
! 	add_man(y + 1 + py2, x + 53);
!         add_man(y + 1 + py3, x + 66);
! 	add_man(y + 1 + py3, x + 74);
      }
      add_smoke(y - 1, x + LOGOFUNNEL);
      return OK;
  }
  
  
! int add_D51_coach(int x, char *c[]) {
      int y, i, dy = 0;
+ #ifdef DEBUG
+     char buf[100];
+ #endif
  
!     if (x < ( - ALL_LENGTH + 4 ))  return ERR;
      y = LINES / 2 - 5;
  
+ #ifdef DEBUG
+     sprintf(buf, "%d", x);
+     my_mvaddstr(1, 0, buf);
+ #endif
      if (FLY == 1) {
  	y = (x / 7) + LINES - (COLS / 7) - D51HIGHT;
  	dy = 1;
      }
+ 
      for (i = 0; i <= D51HIGHT; ++i) {
!       my_mvaddstr(y + i, 0, c[(D51HIGHT + 1) * ((ALL_LENGTH + x) % D51PATTERNS) + i] + COLS - x);
      }
      if (ACCIDENT == 1) {
  	add_man(y + 2, x + 43);
  	add_man(y + 2, x + 47);
+ 	add_man(y + 2, x + 125);
+ 	add_man(y + 2, x + 129);
+ 	add_man(y + 2, x + 207);
+ 	add_man(y + 2, x + 211);
      }
      add_smoke(y - 1, x + D51FUNNEL);
+     add_smoke(y - 1, x + D51FUNNEL + 81);
+     add_smoke(y - 1, x + D51FUNNEL + 162);
+ 
+     return OK;
+ }
+ 
+ 
+ int add_D51_coach_r(int x)
+ {
+     int y, i, j;
+     char num[10];
+ 
+     if (x > ALL_LENGTH + COLS)  return ERR;
+     y = LINES / 2 - 5;
+ 
+     for (i = 0; i <= D51HIGHT; ++i) {
+ 	my_mvaddstr_r(y + i, x, d51_r[(ALL_LENGTH + x) % D51PATTERNS][i]);
+ 	my_mvaddstr_r(y + i, x - 53, coal[i]);
+ 	my_mvaddstr_r(y + i, x - 82, d51_r[(ALL_LENGTH + x) % D51PATTERNS][i]);
+ 	my_mvaddstr_r(y + i, x - 135, coal[i]);
+ 	my_mvaddstr_r(y + i, x - 164, d51_r[(ALL_LENGTH + x) % D51PATTERNS][i]);
+ 	my_mvaddstr_r(y + i, x - 217, coal[i]);
+         for (j = 0; j < PASSNUM - 1; ++j) {
+ 	  my_mvaddstr_r(y + i, x - 246 - (PASSLENGTH * j), coach[i]);
+           if ( i == 3 ) {
+ 	    sprintf(num, "%d", j + 1);
+ 	    my_mvaddstr(y + i, x - 255 - (PASSLENGTH * j), num);
+ 	  }
+         }
+ 	my_mvaddstr_r(y + i, x - 246 - (PASSLENGTH * (PASSNUM - 1)), lcoach[i]);
+ 	if ( i == 3 ) {
+ 	  sprintf(num, "%d", j + 1);
+ 	  my_mvaddstr(y + i, x - 255 - (PASSLENGTH * (PASSNUM - 1)), num);
+ 	}
+     }
+     if (ACCIDENT == 1) {
+ 	add_man(y + 2, x - 45);
+ 	add_man(y + 2, x - 49);
+ 	add_man(y + 2, x - 127);
+ 	add_man(y + 2, x - 131);
+ 	add_man(y + 2, x - 209);
+ 	add_man(y + 2, x - 213);
+     }
+     add_smoke_r(y - 1, x - D51FUNNEL - 3);
+     add_smoke_r(y - 1, x - D51FUNNEL - 84);
+     add_smoke_r(y - 1, x - D51FUNNEL - 167);
      return OK;
  }
  
***************
*** 175,183 ****
--- 661,673 ----
      static char *man[2][2] = {{"", "(O)"}, {"Help!", "\\O/"}};
      int i;
  
+     if ( x < 0 ) {
+       return 0;
+     }
      for (i = 0; i < 2; ++i) {
  	my_mvaddstr(y + i, x, man[(LOGOLENGTH + x) / 12 % 2][i]);
      }
+     return 0;
  }
  
  
***************
*** 209,214 ****
--- 699,707 ----
  				 2,  2, 2, 3, 3, 3             };
      int i;
  
+     if (x < - COLS) {
+       return 0;
+     }
      if (x % 4 == 0) {
  	for (i = 0; i < sum; ++i) {
  	    my_mvaddstr(S[i].y, S[i].x, Eraser[S[i].ptrn]);
***************
*** 222,225 ****
--- 715,767 ----
  	S[sum].ptrn = 0; S[sum].kind = sum % 2;
  	sum ++;
      }
+     return 0;
+ }
+ 
+ 
+ int add_smoke_r(int y, int x)
+ #define SMOKEPTNS	16
+ {
+     static struct smokes {
+ 	int y, x;
+ 	int ptrn, kind;
+     } S[1000];
+     static int sum = 0;
+     static char *Smoke[2][SMOKEPTNS]
+ 	= {{"(   )", "(    )", "(    )", "(   )", "(  )",
+ 	    "(  )" , "( )"   , "( )"   , "()"   , "()"  ,
+ 	    "O"    , "O"     , "O"     , "O"    , "O"   ,
+ 	    " "                                          },
+ 	   {"(@@@)", "(@@@@)", "(@@@@)", "(@@@)", "(@@)",
+ 	    "(@@)" , "(@)"   , "(@)"   , "@@"   , "@@"  ,
+ 	    "@"    , "@"     , "@"     , "@"    , "@"   ,
+ 	    " "                                          }};
+     static char *Eraser[SMOKEPTNS]
+ 	=  {"     ", "      ", "      ", "     ", "    ",
+ 	    "    " , "   "   , "   "   , "  "   , "  "  ,
+ 	    " "    , " "     , " "     , " "    , " "   ,
+ 	    " "                                          };
+     static int dy[SMOKEPTNS] = { 2,  1, 1, 1, 0, 0, 0, 0, 0, 0,
+ 				 0,  0, 0, 0, 0, 0             };
+     static int dx[SMOKEPTNS] = {-2, -1, 0, 1, 1, 1, 1, 1, 2, 2,
+ 				 2,  2, 2, 3, 3, 3             };
+     int i;
+ 
+     if (x > 2 * COLS) {
+       return 0;
+     }
+     if (x % 4 == 0) {
+ 	for (i = 0; i < sum; ++i) {
+ 	    my_mvaddstr_r(S[i].y, S[i].x, Eraser[S[i].ptrn]);
+ 	    S[i].y    -= dy[S[i].ptrn];
+ 	    S[i].x    -= dx[S[i].ptrn];
+ 	    S[i].ptrn += (S[i].ptrn < SMOKEPTNS - 1) ? 1 : 0;
+ 	    my_mvaddstr_r(S[i].y, S[i].x, Smoke[S[i].kind][S[i].ptrn]);
+ 	}
+ 	my_mvaddstr(y, x, Smoke[sum % 2][0]);
+ 	S[sum].y = y;    S[sum].x = x;
+ 	S[sum].ptrn = 0; S[sum].kind = sum % 2;
+ 	sum ++;
+     }
+     return 0;
  }
diff -rcN sl/sl.h sl5-1/sl.h
*** sl/sl.h	Wed Jan 19 02:23:24 1994
--- sl5-1/sl.h	Sat Jun 24 01:33:31 2000
***************
*** 8,14 ****
  
  #define D51HIGHT	10
  #define D51FUNNEL	 7
! #define D51LENGTH       83
  #define D51PATTERNS	 6
  
  
--- 8,15 ----
  
  #define D51HIGHT	10
  #define D51FUNNEL	 7
! /*#define D51LENGTH       82*/
! #define D51LENGTH       172
  #define D51PATTERNS	 6
  
  
***************
*** 46,63 ****
  
  #define D51DEL   "                                                      "
  
! #define COAL01 "                              "
! #define COAL02 "                              "
! #define COAL03 "    _________________         "
! #define COAL04 "   _|                \\_____A  "
! #define COAL05 " =|                        |  "
! #define COAL06 " -|                        |  "
! #define COAL07 "__|________________________|_ "
! #define COAL08 "|__________________________|_ "
! #define COAL09 "   |_D__D__D_|  |_D__D__D_|   "
! #define COAL10 "    \\_/   \\_/    \\_/   \\_/    "
  
! #define COALDEL "                              "
  
  #define LOGOHIGHT    	 6
  #define LOGOFUNNEL  	 4
--- 47,64 ----
  
  #define D51DEL   "                                                      "
  
! #define COAL01 "                             "
! #define COAL02 "                             "
! #define COAL03 "    _________________        "
! #define COAL04 "   _|                \\_____A "
! #define COAL05 " =|                        | "
! #define COAL06 " -|                        | "
! #define COAL07 "__|________________________|_"
! #define COAL08 "|__________________________|_"
! #define COAL09 "   |_D__D__D_|  |_D__D__D_|  "
! #define COAL10 "    \\_/   \\_/    \\_/   \\_/   "
  
! #define COALDEL "                             "
  
  #define LOGOHIGHT    	 6
  #define LOGOFUNNEL  	 4
***************
*** 102,104 ****
--- 103,247 ----
  #define LCAR6  "   (O)        (O)    "
  
  #define DELLN  "                     "
+ 
+ #define PASSLENGTH 88
+ 
+ #define PASS01 "          _____  _____  _____  _____  _____  _____  _____  _____  _____  _____          "
+ #define PASS02 " _________|___|__|___|__|___|__|___|__|___|__|___|__|___|__|___|__|___|__|___|_________ "
+ #define PASS03 "  | ____  _____  _____  _____  _____  _____  _____  _____  _____  _____  _____  ____ |  "
+ #define PASS04 "  | |  |  |   |  |   |  |   |  |   |  |   |  |   |  |   |  |   |  |   |  |   |  |  | |  "
+ #define PASS05 "  | |  |  |___|  |___|  |___|  |___|  |___|  |___|  |___|  |___|  |___|  |___|  |  | |  "
+ #define PASS06 "  | |  |                                                                        |  | |  "
+ #define PASS07 "  | |  |                                   @@                                   |  | |  "
+ #define PASS08 "__|_|__|________________________________________________________________________|__|_|__"
+ #define PASS09 "\\==|_/_\\____/_\\_|  |______|Z          +--|_________________|------+    |_/_\\____/_\\_|==/"
+ #define PASS10 "     \\_/    \\_/                                       +++~~              \\_/    \\_/     "
+ 
+ #define PASSDEL "                                                                                        "
+ 
+ #define LPASSLENGTH 88
+ 
+ #define LPASS01 "          _____  _____  _____  _____  _____  _____  _____  _____  _____  _____           "
+ #define LPASS02 " _________|___|__|___|__|___|__|___|__|___|__|___|__|___|__|___|__|___|__|___|________   "
+ #define LPASS03 "  | ____  _____  _____  _____  _____  _____  _____  _____  _____  _____  ____   _____|   "
+ #define LPASS04 "  | |  |  |   |  |   |  |   |  |   |  |   |  |   |  |   |  |   |  |   |  |  |   |   |    "
+ #define LPASS05 "  | |  |  |___|  |___|  |___|  |___|  |___|  |___|  |___|  |___|  |___|  |  |   |   |    "
+ #define LPASS06 "  | |  |                                                                 |  |   |___|    "
+ #define LPASS07 "  | |  |                                   @@                            |  |   |_|_|    "
+ #define LPASS08 "__|_|__|_________________________________________________________________|__|___|_|_|___ "
+ #define LPASS09 "\\==|_/_\\____/_\\_|  |______|XX                    +-|_______|------+    |_/_\\____/_\\_|==/ "
+ #define LPASS10 "     \\_/    \\_/                                                          \\_/    \\_/      "
+ 
+ #define LPASSDEL "                                                                                         "
+ 
+ #define CROS001 ""
+ #define CROS002 ""
+ #define CROS003 "-_||_-"
+ #define CROS004  "_><_"
+ #define CROS005 "- || -"
+ #define CROS006   "||"
+ #define CROS007   "||"
+ #define CROS008   "||"
+ #define CROS009   "||"
+ #define CROS010 "\\&||~"
+ 
+ static int cros0l[] = {0, 0, 0, 1, 0, 2, 2, 2, 2, 0};
+ 
+ #define CROS101 " |                  "
+ #define CROS102 " |                  "
+ #define CROS103 " |                  "
+ #define CROS104 " |                  "
+ #define CROS105 " |                  "
+ #define CROS106 " |                  "
+ #define CROS107 " |                  "
+ #define CROS108 " |                  "
+ #define CROS109 "_|_                 "
+ #define CROS110 "|||                 "
+ 
+ #define CROS201 "          /         "
+ #define CROS202 "         /          "
+ #define CROS203 "        /           "
+ #define CROS204 "       /            "
+ #define CROS205 "      /             "
+ #define CROS206 "     /              "
+ #define CROS207 "    /               "
+ #define CROS208 "   /                "
+ #define CROS209 "__/                 "
+ #define CROS210 "|/|                 "
+ 
+ #define CROS301 "                    "
+ #define CROS302 "                    "
+ #define CROS303 "                    "
+ #define CROS304 "                    "
+ #define CROS305 "                    "
+ #define CROS306 "                    "
+ #define CROS307 "                    "
+ #define CROS308 "                    "
+ #define CROS309 "___"
+ #define CROS310 "|-+-----------------"
+ 
+ /*#define PASSNUM 5*/
+ /*#define ALL_LENGTH (D51LENGTH + (PASSLENGTH * (PASSNUM - 1)) + LPASSLENGTH)*/
+ 
+ static char *cros0[D51HIGHT]
+ = {CROS001, CROS002, CROS003, CROS004, CROS005,
+    CROS006, CROS007, CROS008, CROS009, CROS010};
+ static char *cros1[D51HIGHT]
+ = {CROS101, CROS102, CROS103, CROS104, CROS105,
+    CROS106, CROS107, CROS108, CROS109, CROS110};
+ static char *cros2[D51HIGHT]
+ = {CROS201, CROS202, CROS203, CROS204, CROS205,
+    CROS206, CROS207, CROS208, CROS209, CROS210};
+ static char *cros3[D51HIGHT]
+ = {CROS301, CROS302, CROS303, CROS304, CROS305,
+    CROS306, CROS307, CROS308, CROS309, CROS310};
+ 
+ static char *sl[LOGOPATTERNS][LOGOHIGHT + 1]
+ = {{LOGO1, LOGO2, LOGO3, LOGO4, LWHL11, LWHL12, DELLN},
+    {LOGO1, LOGO2, LOGO3, LOGO4, LWHL21, LWHL22, DELLN},
+    {LOGO1, LOGO2, LOGO3, LOGO4, LWHL31, LWHL32, DELLN},
+    {LOGO1, LOGO2, LOGO3, LOGO4, LWHL41, LWHL42, DELLN},
+    {LOGO1, LOGO2, LOGO3, LOGO4, LWHL51, LWHL52, DELLN},
+    {LOGO1, LOGO2, LOGO3, LOGO4, LWHL61, LWHL62, DELLN}};
+ static char *lcoal[LOGOHIGHT + 1]
+ = {LCOAL1, LCOAL2, LCOAL3, LCOAL4, LCOAL5, LCOAL6, DELLN};
+ static char *car[LOGOHIGHT + 1]
+ = {LCAR1, LCAR2, LCAR3, LCAR4, LCAR5, LCAR6, DELLN};
+ 
+ static char *d51[D51PATTERNS][D51HIGHT + 1]
+ = {{D51STR1, D51STR2, D51STR3, D51STR4, D51STR5, D51STR6, D51STR7,
+     D51WHL11, D51WHL12, D51WHL13, D51DEL},
+    {D51STR1, D51STR2, D51STR3, D51STR4, D51STR5, D51STR6, D51STR7,
+     D51WHL21, D51WHL22, D51WHL23, D51DEL},
+    {D51STR1, D51STR2, D51STR3, D51STR4, D51STR5, D51STR6, D51STR7,
+     D51WHL31, D51WHL32, D51WHL33, D51DEL},
+    {D51STR1, D51STR2, D51STR3, D51STR4, D51STR5, D51STR6, D51STR7,
+     D51WHL41, D51WHL42, D51WHL43, D51DEL},
+    {D51STR1, D51STR2, D51STR3, D51STR4, D51STR5, D51STR6, D51STR7,
+     D51WHL51, D51WHL52, D51WHL53, D51DEL},
+    {D51STR1, D51STR2, D51STR3, D51STR4, D51STR5, D51STR6, D51STR7,
+     D51WHL61, D51WHL62, D51WHL63, D51DEL}};
+ static char *coal[D51HIGHT + 1]
+ = {COAL01, COAL02, COAL03, COAL04, COAL05,
+    COAL06, COAL07, COAL08, COAL09, COAL10, COALDEL};
+ static char *coach[D51HIGHT + 1]
+ = {PASS01, PASS02, PASS03, PASS04, PASS05,
+    PASS06, PASS07, PASS08, PASS09, PASS10, PASSDEL};
+ static char *lcoach[D51HIGHT + 1]
+ = {LPASS01, LPASS02, LPASS03, LPASS04, LPASS05,
+    LPASS06, LPASS07, LPASS08, LPASS09, LPASS10, LPASSDEL};
+ 
+ static char *d51_r[D51PATTERNS][D51HIGHT + 1]
+ = {{D51STR1, D51STR2, D51STR3, D51STR4, D51STR5, D51STR6, D51STR7,
+     D51WHL11, D51WHL12, D51WHL13, D51DEL},
+    {D51STR1, D51STR2, D51STR3, D51STR4, D51STR5, D51STR6, D51STR7,
+     D51WHL61, D51WHL62, D51WHL63, D51DEL},
+    {D51STR1, D51STR2, D51STR3, D51STR4, D51STR5, D51STR6, D51STR7,
+     D51WHL51, D51WHL52, D51WHL53, D51DEL},
+    {D51STR1, D51STR2, D51STR3, D51STR4, D51STR5, D51STR6, D51STR7,
+     D51WHL41, D51WHL42, D51WHL43, D51DEL},
+    {D51STR1, D51STR2, D51STR3, D51STR4, D51STR5, D51STR6, D51STR7,
+     D51WHL31, D51WHL32, D51WHL33, D51DEL},
+    {D51STR1, D51STR2, D51STR3, D51STR4, D51STR5, D51STR6, D51STR7,
+     D51WHL21, D51WHL22, D51WHL23, D51DEL}};
+ 
